constant symbol Set : TYPE;
injective symbol El : Set → TYPE;

constant symbol π : Π A : Set, (El A → Set) → Set;
rule El (π $A $B) ↪ Π (x : El $A), El ($B x);

constant symbol W : Π (A : Set),       // set of nodes
                      (El A → Set) → // for each node, a set of edges
                      Set;             // set of trees

constant symbol introW : Π (A : Set) (B : El A → Set) 
                           (a : El A),                 // a node of the tree
                           (El (B a) → El (W A B)) → // for each edge of 'a', a subtree
                           El (W A B);                 // the tree generated by 'a'

symbol elimW : Π (A : Set) (B : El A → Set) 
                 (C : El (W A B) → Set),              // predicate on W A B
                   (Π (x : El A)                       // a node of A
                   (u : El (B x) → El (W A B))        // for each edge, a subtree
                   (v : Π y : El (B x), El (C (u y))), // a proof of C for each subtree
                   El (C (introW A B x u))) →         // then a proof of C for the sup tree 
                 Π (w : El (W A B)), El (C w);

type λ A B C c x u, elimW A B C c (introW A B x u);

rule elimW $A $B $C $c (introW _ _ $x $u) ↪ $c $x $u (λ y, elimW $A $B $C $c ($u y));


constant symbol ⊥ : Set;
rule El ⊥ ↪ Π (A : Set), El A;

constant symbol ⊤ : Set;
constant symbol I : El ⊤;

constant symbol Bool : Set;
constant symbol tt : El Bool;
constant symbol ff : El Bool;
symbol elBool : Π P : El Bool → Set, El (P tt) → El (P ff) → Π (b : El Bool), El (P b);
rule elBool _ $pt _ tt ↪ $pt;
rule elBool _ _ $pf ff ↪ $pf;

symbol f : El Bool → Set;
rule f tt ↪ ⊤
with f ff ↪ ⊥;


symbol Nat ≔ W Bool f;
symbol zero : El Nat ≔ introW Bool f ff (λ p, p (W Bool f));
symbol succ : El Nat → El Nat ≔ λ a, introW Bool f tt (λ _, a);

symbol m : Π (P : El Nat → Set)
             (p0 : El (P zero))
             (ps : Π n : El Nat, El (P n) → El (P (succ n)))
             (x : El Bool)
             (u : El (f x) → El Nat)
             (v : Π y : El (f x), El (P (u y))),
             El (P (introW Bool f x u));

symbol elNat : Π (P : El Nat → Set), 
               El (P zero) → 
               (Π n : El Nat, El (P n) → El (P (succ n))) →
               Π n : El Nat, El (P n) ≔
  λ P P0 PS, elimW Bool f P (m P P0 PS);


//rule m $P $p0 $ps tt $u $v ↪ $ps ($u I) ($v I);
// why does not type check ?

type λ (P : El Nat → Set) (ps : Π n : El Nat, El (P n) → El (P (succ n)))
       (u : El (f tt) → El Nat)
       (v : Π y : El (f tt), El (P (u y))), ps (u I) (v I);
compute Π P: (El Nat → Set), (Π n: El Nat, El (P n) → El (P (succ n))) → Π u: (El (f tt) → El Nat), (Π y: El (f tt), El (P (u y))) → El (P (succ (u I)));

// we get El (P (introW Bool f tt (λ _, u I))) whereas we should have
// El (P (introW Bool f x u)). (λ _, u I) and u are propositionally equal,
// but not definitionally 


// similar problem with p0
//rule m $P $p0 $ps ff $u $v ↪ $p0;

